import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.ensemble import RandomForestRegressor
from sklearn.model_selection import KFold
from sklearn.metrics import r2_score, mean_squared_error, mean_absolute_error, mean_absolute_percentage_error
from tqdm.notebook import tqdm
import warnings

warnings.filterwarnings("ignore")

# ==========================================
# 1. 参数设置 (已修正为与 SHAP 代码完全一致)
# ==========================================
PATH = r"C:\Users\Administrator\GWRF"
TRAIN_FILE = "train_data_0610.xlsx"     
PREDICT_FILE = "predict_data_0610.xlsx" 

BANDWIDTH = 15000  
TARGET_COL = 'Y'
COORD_COLS = ['y_cordinat', 'x_cordinat']

FEATURE_COLS = [
    'SHDI', 'SHAPE', 'PD', 'CONTIG', 
    'DistFacility', 'DistWater', 'DistAccommodation', 'DistRoad', 
    'DistRestaurant', 'DistMountain', 'DistScenicSite', 'DistBusStop', 
    'Terrain relief', 'TRI', 'Annual NDVI', 'Elevation', 'Travel time'
]

# 【关键修正】这里定义统一的 RF 参数，确保训练、预测、SHAP 三者一致
RF_PARAMS = {
    'n_estimators': 100,      # 修正：从 40 改回 100
    'max_depth': 10,          # 修正：从 6 改回 10
    'min_samples_split': 5,   # 修正：增加此参数以匹配 SHAP 代码
    'n_jobs': 1,              # 局部模型单线程，避免死锁
    'random_state': 42
}

# ==========================================
# 2. 核心函数定义
# ==========================================
def calculate_weights(coords_train, target_point, bandwidth):
    """
    计算高斯权重 (使用 NumPy 向量化加速，适合大规模循环)
    虽然 SHAP 代码用了 geopy，但为了预测效率，这里使用球面距离近似是可接受的
    """
    lats = coords_train.iloc[:, 0].values
    lons = coords_train.iloc[:, 1].values
    t_lat, t_lon = target_point
    
    R = 6371000 # 地球半径 (米)
    dlat = np.radians(lats - t_lat)
    dlon = np.radians(lons - t_lon)
    a = np.sin(dlat/2)**2 + np.cos(np.radians(t_lat)) * np.cos(np.radians(lats)) * np.sin(dlon/2)**2
    c = 2 * np.arctan2(np.sqrt(a), np.sqrt(1-a))
    distances = R * c
    
    return np.exp(-0.5 * (distances / bandwidth) ** 2)

def evaluate_performance(X, y, coords, bandwidth):
    """5折交叉验证评估模型性能"""
    print("\n==== 1. 正在评估模型性能 (5-Fold CV) ====")
    kf = KFold(n_splits=5, shuffle=True, random_state=42)
    
    metrics = {'R2': [], 'RMSE': [], 'MSE': [], 'MAE': [], 'MAPE': []}
    
    fold = 0
    for train_idx, test_idx in kf.split(X):
        fold += 1
        X_train, X_test = X.iloc[train_idx], X.iloc[test_idx]
        y_train, y_test = y.iloc[train_idx], y.iloc[test_idx]
        coords_train, coords_test = coords.iloc[train_idx], coords.iloc[test_idx]
        
        preds = []
        # 针对测试集的每个点进行预测
        for i in range(len(X_test)):
            target_pt = (coords_test.iloc[i, 0], coords_test.iloc[i, 1])
            w = calculate_weights(coords_train, target_pt, bandwidth)
            
            # 混合策略
            if np.sum(w > 0.05) < 5:
                preds.append(y_train.mean())
                continue
                
            try:
                # 【修正】使用统一的 RF_PARAMS
                lrf = RandomForestRegressor(**RF_PARAMS)
                lrf.fit(X_train, y_train, sample_weight=w)
                preds.append(lrf.predict(X_test.iloc[[i]])[0])
            except:
                preds.append(y_train.mean())
        
        # 计算指标
        metrics['R2'].append(r2_score(y_test, preds))
        metrics['RMSE'].append(np.sqrt(mean_squared_error(y_test, preds)))
        metrics['MSE'].append(mean_squared_error(y_test, preds))
        metrics['MAE'].append(mean_absolute_error(y_test, preds))
        metrics['MAPE'].append(mean_absolute_percentage_error(y_test, preds))
        
        print(f"  Fold {fold}: R2={metrics['R2'][-1]:.4f}")

    # 输出汇总表
    print("\n========== 模型性能指标 (Model Performance) ==========")
    print(f"{'Metric':<10} | {'Mean':<10} | {'Std. Dev':<10}")
    print("-" * 45)
    for k, v in metrics.items():
        if k == 'MAPE':
            print(f"{k:<10} | {np.mean(v):.2%}      | ± {np.std(v):.2%}")
        else:
            print(f"{k:<10} | {np.mean(v):.4f}      | ± {np.std(v):.4f}")
    print("-" * 45)

# ==========================================
# 3. 主程序逻辑
# ==========================================
def run_full_process():
    # --- 加载数据 ---
    print(f"正在加载数据...\n路径: {PATH}")
    try:
        df_train = pd.read_excel(f"{PATH}\\{TRAIN_FILE}")
        df_pred = pd.read_excel(f"{PATH}\\{PREDICT_FILE}")
        print(f"✅ 加载成功: 训练集 {len(df_train)} 条, 预测集 {len(df_pred)} 条")
    except Exception as e:
        print(f"❌ 读取失败: {e}")
        return

    # 检查列
    missing_train = [c for c in FEATURE_COLS if c not in df_train.columns]
    if missing_train:
        print(f"❌ 训练集缺少特征: {missing_train}")
        return

    X_train = df_train[FEATURE_COLS]
    y_train = df_train[TARGET_COL]
    coords_train = df_train[COORD_COLS]
    
    X_pred = df_pred[FEATURE_COLS]
    coords_pred = df_pred[COORD_COLS]

    # --- 步骤 1: 评估模型 ---
    evaluate_performance(X_train, y_train, coords_train, BANDWIDTH)
    
    # --- 步骤 2: 训练全局基准模型 (参数也应尽量匹配，但n_jobs可并行) ---
    print("\n==== 2. 训练全局基准模型 (Global RF Baseline) ====")
    global_params = RF_PARAMS.copy()
    global_params['n_jobs'] = -1 # 全局模型允许并行
    global_rf = RandomForestRegressor(**global_params)
    global_rf.fit(X_train, y_train)
    print("全局模型训练完毕。")

    # --- 步骤 3: 全市预测 ---
    print(f"\n==== 3. 开始全市预测 (Predicting {len(X_pred)} points) ====")
    print(f"带宽: {BANDWIDTH}m | 参数: Est=100, Depth=10")
    
    y_pred_final = []
    status_flags = [] 
    
    for i in tqdm(range(len(X_pred))):
        target_pt = (coords_pred.iloc[i, 0], coords_pred.iloc[i, 1])
        w = calculate_weights(coords_train, target_pt, bandwidth=BANDWIDTH)
        
        # 混合策略: 孤岛点用全局模型
        if np.sum(w > 0.05) < 5:
            pred = global_rf.predict(X_pred.iloc[[i]])[0]
            y_pred_final.append(pred)
            status_flags.append(1) 
            continue

        try:
            # 【修正】使用统一的 RF_PARAMS
            lrf = RandomForestRegressor(**RF_PARAMS)
            lrf.fit(X_train, y_train, sample_weight=w)
            
            pred = lrf.predict(X_pred.iloc[[i]])[0]
            y_pred_final.append(pred)
            status_flags.append(0) 
            
        except:
            pred = global_rf.predict(X_pred.iloc[[i]])[0]
            y_pred_final.append(pred)
            status_flags.append(1)

    # --- 步骤 4: 保存与可视化 ---
    df_pred['Predicted_Y'] = y_pred_final
    df_pred['Prediction_Type'] = ['Global_Fill' if s==1 else 'GWRF' for s in status_flags]
    
    save_path = f"{PATH}\\City_Prediction_Result_15k.xlsx"
    df_pred.to_excel(save_path, index=False)
    
    print(f"\n✅ 预测完成！")
    print(f"   - GWRF 预测点数: {status_flags.count(0)}")
    print(f"   - Global 填充点数: {status_flags.count(1)}")
    print(f"   - 结果已保存至: {save_path}")
    
    # 画图
    plt.figure(figsize=(12, 10))
    sc = plt.scatter(df_pred['x_cordinat'], df_pred['y_cordinat'], 
                     c=df_pred['Predicted_Y'], cmap='Spectral_r', 
                     s=10, alpha=0.9)
    plt.colorbar(sc, label='Predicted Recreation Service Value')
    plt.title(f"City-wide Prediction Map (Bandwidth: {BANDWIDTH}m)")
    plt.xlabel("Longitude")
    plt.ylabel("Latitude")
    plt.axis('equal')
    plt.show()

if __name__ == "__main__":
    run_full_process()
